{"version":3,"file":"communitySbt.js","sourceRoot":"/","sources":["entities/communitySbt.ts"],"names":[],"mappings":"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","sourcesContent":["import { BigNumber, Bytes, Signer, providers } from 'ethers';\nimport { gql } from '@apollo/client';\nimport axios from 'axios';\nimport { DateTime } from 'luxon';\nimport { CommunitySBT, CommunitySBT__factory } from '../typechain-sbt';\nimport { createLeaves } from '../utils/communitySbt/getIpfsLeaves';\nimport { getRootFromSubgraph } from '../utils/communitySbt/getSubgraphRoot';\nimport { getProof } from '../utils/communitySbt/merkle-tree';\nimport { MULTI_REDEEM_METHOD_ID, ONE_DAY_IN_SECONDS, REDEEM_METHOD_ID } from '../constants';\nimport {\n  decodeBadgeType,\n  decodeMultipleBadgeTypes,\n  get100KRefereeBenchmark,\n  get2MRefereeBenchmark,\n  getEtherscanURL,\n  getLeavesIpfsUri,\n  getSelectedSeasonBadgesUrl,\n  getTopBadgeType,\n  toMillis,\n} from '../utils/communitySbt/helpers';\nimport { getScores, GetScoresArgs } from '../utils/communitySbt/getTopBadges';\nimport { getSubgraphBadges } from '../utils/communitySbt/getSubgraphBadges';\n\nimport { sentryTracker } from '../utils/sentry';\nimport { getApolloClient } from '../utils/communitySbt/getApolloClient';\nimport { geckoEthToUsd } from '../utils/priceFetch';\n\nexport type SBTConstructorArgs = {\n  id: string;\n  signer: Signer | null;\n  coingeckoKey?: string;\n  currentBadgesSubgraphUrl?: string;\n  nextBadgesSubgraphUrl?: string;\n  nonProgDbUrl?: string;\n  referralsDbUrl?: string;\n  subgraphUrl?: string;\n  ignoredWalletIds?: Record<string, boolean>;\n  badgesCids?: Array<string>;\n  leavesCids?: Array<string>;\n};\n\nexport type BadgeRecord = {\n  badgeType: string;\n  awardedTimestamp: number;\n};\n\nexport type LeafInfo = {\n  account: string;\n  badgeId: number;\n};\n\ntype MultiRedeemData = {\n  leaves: Array<LeafInfo>;\n  proofs: Array<string[]>;\n  roots: Array<Bytes>;\n};\n\nexport type BadgeResponse = {\n  id: string;\n  badgeType: string;\n  awardedTimestampMs?: number;\n  mintedTimestampMs?: number;\n};\n\nexport type SubgraphBadgeResponse = {\n  id: string;\n  badgeType: string;\n  awardedTimestamp: string;\n  mintedTimestamp: string;\n};\n\nexport type GetRankingArgs = {\n  seasonStart: number;\n  seasonEnd: number;\n  subgraphUrl?: string;\n  ethPrice?: number;\n  ignoredWalletIds?: Record<string, boolean>;\n  isLP?: boolean;\n};\n\nexport type RankType = {\n  address: string;\n  points: number;\n  rank: number;\n};\n\nenum TxBadgeStatus {\n  SUCCESSFUL,\n  FAILED,\n  PENDING,\n}\n\nexport enum BadgeClaimingStatus {\n  CLAIMED,\n  CLAIMING,\n  NOT_CLAIMED,\n}\n\nexport type BadgeWithStatus = {\n  badgeType: number;\n  claimingStatus: BadgeClaimingStatus;\n};\n\nexport type GetBadgesStatusArgs = {\n  apiKey: string;\n  subgraphUrl: string;\n  season: number;\n  potentialClaimingBadgeTypes: Array<number>;\n};\n\nexport type NonProgramaticBadgeResponse = {\n  address: string;\n  badge: string;\n  awardedTimestamp: number;\n};\n\nexport const TOP_BADGES_VARIANT: Record<string, string[]> = {\n  trader: ['15', '31', '56'],\n  liquidityProvider: ['12', '28', '53'],\n};\n\nexport const NON_PROGRAMATIC_BADGES_VARIANT: Record<number, Record<string, string>> = {\n  1: {\n    diplomatz: '33',\n    governorz: '34',\n    senatorz: '35',\n  },\n  2: {\n    diplomatz: '57',\n    governorz: '58',\n    senatorz: '59',\n  },\n};\n\nexport const REFERROR_BADGES_VARIANT: Record<number, Record<string, string>> = {\n  1: {\n    referror: '36',\n    notionalInfluencer: '37',\n    whaleWhisperer: '38',\n  },\n  2: {\n    referror: '60',\n    notionalInfluencer: '61',\n    whaleWhisperer: '62',\n  },\n};\n\nexport const NON_SUBGRAPH_BADGES_SEASONS: Record<number, string[]> = {\n  0: [TOP_BADGES_VARIANT.trader[0], TOP_BADGES_VARIANT.liquidityProvider[0]],\n  1: [\n    TOP_BADGES_VARIANT.trader[1],\n    TOP_BADGES_VARIANT.liquidityProvider[1],\n    NON_PROGRAMATIC_BADGES_VARIANT[1].diplomatz,\n    NON_PROGRAMATIC_BADGES_VARIANT[1].governorz,\n    NON_PROGRAMATIC_BADGES_VARIANT[1].senatorz,\n    REFERROR_BADGES_VARIANT[1].referror,\n    REFERROR_BADGES_VARIANT[1].notionalInfluencer,\n    REFERROR_BADGES_VARIANT[1].whaleWhisperer,\n  ],\n  2: [\n    TOP_BADGES_VARIANT.trader[2],\n    TOP_BADGES_VARIANT.liquidityProvider[2],\n    NON_PROGRAMATIC_BADGES_VARIANT[2].diplomatz,\n    NON_PROGRAMATIC_BADGES_VARIANT[2].governorz,\n    NON_PROGRAMATIC_BADGES_VARIANT[2].senatorz,\n    REFERROR_BADGES_VARIANT[2].referror,\n    REFERROR_BADGES_VARIANT[2].notionalInfluencer,\n    REFERROR_BADGES_VARIANT[2].whaleWhisperer,\n  ],\n};\n\nclass SBT {\n  public readonly id: string;\n  public readonly signer: Signer | null;\n  public readonly provider: providers.Provider | undefined;\n  public readonly coingeckoKey?: string;\n  public readonly currentBadgesSubgraphUrl?: string;\n  public readonly nextBadgesSubgraphUrl?: string;\n  public readonly nonProgDbUrl?: string;\n  public readonly referralsDbUrl?: string;\n  public readonly subgraphUrl?: string;\n  public readonly ignoredWalletIds?: Record<string, boolean>;\n  public readonly badgesCids?: Array<string>;\n  public readonly leavesCids?: Array<string>;\n  public contract: CommunitySBT | null;\n  public ethPrice: number | undefined;\n\n  /**\n   *\n   * @param id: CommunitySBT contract address (depends on the network)\n   * @param signer: Signer object according to the user's wallet\n   */\n  public constructor({\n    id,\n    signer,\n    coingeckoKey,\n    currentBadgesSubgraphUrl,\n    nextBadgesSubgraphUrl,\n    nonProgDbUrl,\n    referralsDbUrl,\n    subgraphUrl,\n    ignoredWalletIds,\n    badgesCids,\n    leavesCids,\n  }: SBTConstructorArgs) {\n    this.id = id;\n    this.signer = signer;\n\n    this.coingeckoKey = coingeckoKey;\n    this.currentBadgesSubgraphUrl = currentBadgesSubgraphUrl;\n    this.nextBadgesSubgraphUrl = nextBadgesSubgraphUrl;\n    this.nonProgDbUrl = nonProgDbUrl;\n    this.referralsDbUrl = referralsDbUrl;\n    this.subgraphUrl = subgraphUrl;\n    this.ignoredWalletIds = ignoredWalletIds ?? {};\n    this.badgesCids = badgesCids;\n    this.leavesCids = leavesCids;\n    if (signer) {\n      this.contract = CommunitySBT__factory.connect(id, signer);\n      this.provider = signer.provider;\n    } else {\n      this.contract = null;\n    }\n  }\n\n  /**\n   * @notice This function calls the SBT contract's\n   * @param badgeType: number associated with the badge to redeem\n   * @param owner: user's address\n   * @param awardedTimestamp: time at which the badge was awarded (taken from the subgraph)\n   * @param subgraphAPI: the api link used to query the subgraph\n   * @returns\n   */\n  public async redeemSbt(\n    badgeType: string,\n    owner: string,\n    seasonId: number,\n    awardedTimestamp: number,\n  ): Promise<BigNumber | void> {\n    // wallet was not connected when the object was initialised\n    // therefore, it couldn't obtain the contract connection\n    if (!this.contract) {\n      throw new Error('Cannot connect to community SBT contract');\n    }\n\n    const selectedBadgesSubgraphUrl = getSelectedSeasonBadgesUrl(\n      seasonId,\n      this.badgesCids,\n      this.currentBadgesSubgraphUrl,\n      this.nextBadgesSubgraphUrl,\n    );\n\n    try {\n      if (\n        !selectedBadgesSubgraphUrl ||\n        !this.coingeckoKey ||\n        !this.subgraphUrl ||\n        !this.provider ||\n        !this.leavesCids\n      ) {\n        throw new Error('Missing env vars');\n      }\n\n      const awardedTimestampSec = Math.floor(awardedTimestamp / 1000);\n      // create merkle tree from subgraph derived leaves and get the root\n      const rootEntity = await getRootFromSubgraph(awardedTimestampSec, selectedBadgesSubgraphUrl);\n      if (!rootEntity) {\n        throw new Error('No root found');\n      }\n      const leafInfo: LeafInfo = {\n        account: owner,\n        badgeId: parseInt(badgeType),\n      };\n\n      const leaves = await createLeaves(seasonId, this.leavesCids);\n      const proof = getProof(owner, parseInt(badgeType), leaves);\n\n      const tokenId = await this.contract.callStatic.redeem(leafInfo, proof, rootEntity.merkleRoot);\n      const tx = await this.contract.redeem(leafInfo, proof, rootEntity.merkleRoot);\n      await tx.wait();\n      return tokenId;\n    } catch (error) {\n      sentryTracker.captureException(error);\n      sentryTracker.captureMessage('Unable to claim');\n      throw new Error('Unable to claim');\n    }\n  }\n\n  /**\n   * @notice This function calls the SBT contract's\n   * @param badges: array of badgeTypes and the time at which they were awarded\n   * @param owner: user's address\n   * @param subgraphAPI: the api link used to query the subgraph\n   * @returns\n   */\n  public async redeemMultipleSbts(\n    badges: BadgeRecord[],\n    owner: string,\n    seasonId: number,\n  ): Promise<{\n    claimedBadgeTypes: number[];\n  }> {\n    // wallet was not connected when the object was initialised\n    // therefore, it couldn't obtain the contract connection\n    if (!this.contract || !this.provider || !this.leavesCids) {\n      throw new Error('Wallet not connected');\n    }\n\n    // parse through badges and create\n    // multiRedeem(LeafInfo[] memory leafInfos, bytes32[][] calldata proofs, bytes32[] memory merkleRoots)\n    const data: MultiRedeemData = {\n      leaves: [],\n      proofs: [],\n      roots: [],\n    };\n\n    const selectedBadgesSubgraphUrl = getSelectedSeasonBadgesUrl(\n      seasonId,\n      this.badgesCids,\n      this.currentBadgesSubgraphUrl,\n      this.nextBadgesSubgraphUrl,\n    );\n\n    const claimedBadgeTypes: number[] = [];\n    for (const badge of badges) {\n      if (!selectedBadgesSubgraphUrl || !this.coingeckoKey || !this.subgraphUrl) {\n        break;\n      }\n\n      const awardedTimestampSec = Math.floor(badge.awardedTimestamp / 1000);\n      // create merkle tree from subgraph derived leaves and get the root\n      const rootEntity = await getRootFromSubgraph(awardedTimestampSec, selectedBadgesSubgraphUrl);\n      if (!rootEntity) {\n        continue;\n      }\n      const leafInfo: LeafInfo = {\n        account: owner,\n        badgeId: parseInt(badge.badgeType),\n      };\n\n      const leaves = await createLeaves(seasonId, this.leavesCids);\n      const proof = getProof(owner, parseInt(badge.badgeType), leaves);\n\n      data.leaves.push(leafInfo);\n      data.proofs.push(proof);\n      data.roots.push(rootEntity.merkleRoot);\n      claimedBadgeTypes.push(parseInt(badge.badgeType));\n    }\n\n    try {\n      await this.contract.callStatic.multiRedeem(data.leaves, data.proofs, data.roots);\n      const tx = await this.contract.multiRedeem(data.leaves, data.proofs, data.roots);\n      await tx.wait();\n      return {\n        claimedBadgeTypes,\n      };\n    } catch (error) {\n      sentryTracker.captureException(error);\n      sentryTracker.captureMessage('Unable to claim multiple badges');\n      throw new Error('Unable to claim multiple badges');\n    }\n  }\n\n  public async getSeasonBadges({\n    userId,\n    seasonId,\n    seasonStart,\n    seasonEnd,\n  }: {\n    userId: string;\n    seasonId: number;\n    seasonStart: number;\n    seasonEnd: number;\n  }): Promise<BadgeResponse[]> {\n    try {\n      const selectedBadgesSubgraphUrl = getSelectedSeasonBadgesUrl(\n        seasonId,\n        this.badgesCids,\n        this.currentBadgesSubgraphUrl,\n        this.nextBadgesSubgraphUrl,\n      );\n      if (seasonEnd < DateTime.now().toSeconds() && this.badgesCids && this.badgesCids[seasonId]) {\n        const badges = await this.getOldSeasonBadges({\n          userId,\n          seasonId,\n          seasonStart,\n          seasonEnd,\n          selectedBadgesSubgraphUrl,\n        });\n        return badges;\n      }\n      const badges = await this.computeSeasonBadges({\n        userId,\n        seasonId,\n        seasonStart,\n        seasonEnd,\n        selectedBadgesSubgraphUrl,\n      });\n      return badges;\n    } catch (error) {\n      sentryTracker.captureException(error);\n      sentryTracker.captureMessage('Failed to get season badges');\n      throw new Error('Failed to get season badges');\n    }\n  }\n\n  public async getOldSeasonBadges({\n    userId,\n    seasonId,\n    seasonStart,\n    seasonEnd,\n    selectedBadgesSubgraphUrl,\n  }: {\n    userId: string;\n    seasonId: number;\n    seasonStart: number;\n    seasonEnd: number;\n    selectedBadgesSubgraphUrl?: string;\n  }): Promise<BadgeResponse[]> {\n    if (!this.provider || !this.signer || !this.badgesCids) {\n      throw new Error('Wallet not connected');\n    }\n\n    // programmatic badges\n    const badgesResponse: BadgeResponse[] = await getSubgraphBadges({\n      userId,\n      seasonId,\n      seasonStart,\n      seasonEnd,\n      badgesSubgraphUrl: selectedBadgesSubgraphUrl,\n    });\n    const mapBadges = new Map<string, BadgeResponse>();\n    badgesResponse.forEach((entry) => {\n      mapBadges.set(entry.id, entry);\n    });\n\n    const data = await axios.get(getLeavesIpfsUri(seasonId, this.badgesCids), {\n      headers: {\n        Accept: 'text/plain',\n      },\n    });\n\n    const snasphots: Array<{\n      owner: string;\n      badgeType: number;\n      metadataURI: string;\n    }> = data.data.snapshot;\n\n    // to speed things up, awarded timestamp\n    const subgraphSnapshots: BadgeResponse[] = [];\n    snasphots.forEach((entry) => {\n      if (entry.owner.toLowerCase() === userId.toLowerCase()) {\n        const id = `${entry.owner.toLowerCase()}#${entry.badgeType}#${seasonId}`;\n        subgraphSnapshots.push({\n          id,\n          badgeType: entry.badgeType.toString(),\n          awardedTimestampMs:\n            mapBadges.get(id)?.awardedTimestampMs || toMillis(seasonEnd - ONE_DAY_IN_SECONDS),\n          mintedTimestampMs: mapBadges.get(id)?.mintedTimestampMs || undefined,\n        });\n      }\n    });\n\n    return subgraphSnapshots;\n  }\n\n  public async computeSeasonBadges({\n    userId,\n    seasonId,\n    seasonStart,\n    seasonEnd,\n    selectedBadgesSubgraphUrl,\n  }: {\n    userId: string;\n    seasonId: number;\n    seasonStart: number;\n    seasonEnd: number;\n    selectedBadgesSubgraphUrl?: string;\n  }): Promise<BadgeResponse[]> {\n    try {\n      // programmatic badges\n      const badgesResponse: BadgeResponse[] = await getSubgraphBadges({\n        userId,\n        seasonId,\n        seasonStart,\n        seasonEnd,\n        badgesSubgraphUrl: selectedBadgesSubgraphUrl,\n      });\n\n      // referrer badges & non-programatic badges\n      let referroorBadges: Record<string, BadgeResponse> = {};\n      let nonProgBadges: Record<string, BadgeResponse> = {};\n      if (this.nonProgDbUrl) {\n        nonProgBadges = await this.getNonProgramaticBadges(\n          userId,\n          seasonId,\n          seasonStart,\n          seasonEnd,\n        );\n      }\n\n      if (this.referralsDbUrl && selectedBadgesSubgraphUrl) {\n        referroorBadges = await this.getReferrorBadges(userId, seasonId, selectedBadgesSubgraphUrl);\n      }\n\n      for (const badgeType of NON_SUBGRAPH_BADGES_SEASONS[seasonId]) {\n        if (nonProgBadges[badgeType]) {\n          const nonProgBadge = nonProgBadges[badgeType];\n          badgesResponse.push(nonProgBadge);\n        }\n        if (referroorBadges[badgeType]) {\n          const referroorBadge = referroorBadges[badgeType];\n          badgesResponse.push(referroorBadge);\n        }\n      }\n\n      // top LP & trader badges\n      if (\n        selectedBadgesSubgraphUrl &&\n        this.subgraphUrl &&\n        this.coingeckoKey &&\n        DateTime.now().toSeconds() > seasonEnd\n      ) {\n        const topLpBadge = await this.getTopBadge(\n          userId,\n          seasonId,\n          false,\n          seasonStart,\n          seasonEnd,\n          selectedBadgesSubgraphUrl,\n        );\n        const topTraderBadge = await this.getTopBadge(\n          userId,\n          seasonId,\n          true,\n          seasonStart,\n          seasonEnd,\n          selectedBadgesSubgraphUrl,\n        );\n        if (topLpBadge) badgesResponse.push(topLpBadge);\n        if (topTraderBadge) badgesResponse.push(topTraderBadge);\n      }\n\n      return badgesResponse;\n    } catch (error) {\n      sentryTracker.captureException(error);\n      return [];\n    }\n  }\n\n  /**\n   * @dev Retrieve season's notional\n   * ranking of all users. Check if given user is in top 5.\n   * If so, assign a top trader/LP badge, otherwise return undefined\n   */\n  public async getTopBadge(\n    userId: string,\n    seasonId: number,\n    isLP: boolean,\n    seasonStart: number,\n    seasonEnd: number,\n    selectedBadgesSubgraphUrl?: string,\n  ): Promise<BadgeResponse | undefined> {\n    const badgeType = getTopBadgeType(seasonId, !isLP);\n    if (!badgeType) return undefined;\n\n    if (!selectedBadgesSubgraphUrl || !this.coingeckoKey || !this.ignoredWalletIds) {\n      return undefined;\n    }\n\n    if (!this.ethPrice) {\n      this.ethPrice = await geckoEthToUsd(this.coingeckoKey);\n    }\n\n    const rankResult = await this.getRanking({\n      seasonStart,\n      seasonEnd,\n      isLP,\n    });\n\n    for (let rank = 0; rank < 5; rank++) {\n      if (!rankResult[rank]) {\n        return undefined;\n      }\n      const entry = rankResult[rank];\n      if (entry.address === userId) {\n        const badge = await this.constructTopBadge(\n          userId,\n          seasonId,\n          seasonEnd,\n          badgeType,\n          selectedBadgesSubgraphUrl,\n        );\n        return badge;\n      }\n    }\n\n    return undefined;\n  }\n\n  public async getRanking(args: GetRankingArgs): Promise<RankType[]> {\n    if (!this.subgraphUrl || !this.coingeckoKey || !this.ignoredWalletIds) {\n      return [];\n    }\n\n    if (!this.ethPrice) {\n      this.ethPrice = await geckoEthToUsd(this.coingeckoKey);\n    }\n\n    const scoreArgs: GetScoresArgs = {\n      seasonStart: args.seasonStart,\n      seasonEnd: args.seasonEnd,\n      subgraphUrl: this.subgraphUrl,\n      ethPrice: this.ethPrice,\n      ignoredWalletIds: this.ignoredWalletIds,\n      isLP: args.isLP ?? false,\n    };\n\n    const scores = await getScores(scoreArgs);\n\n    const rankResult: RankType[] = Object.keys(scores)\n      .sort((a, b) => scores[b] - scores[a])\n      .map((walletId, index) => ({\n        address: walletId,\n        points: scores[walletId] ?? 0,\n        rank: index,\n      }));\n\n    return rankResult;\n  }\n\n  /**\n   * @dev Query the Badges subgraph to assess if the top\n   * badge was claimed. Create a Badge Response with\n   * the awarded time as end of season and claimed time\n   * as eithr zero if not claimed or subgrap's minted timestamp\n   */\n  async constructTopBadge(\n    userId: string,\n    seasonId: number,\n    seasonEnd: number,\n    badgeType: string,\n    selectedBadgesSubgraphUrl?: string,\n  ): Promise<BadgeResponse> {\n    const badgeQuery = `\n            query( $id: String) {\n                badge(id: $id){\n                    id\n                    mintedTimestamp\n                }\n            }\n        `;\n    const client = getApolloClient(selectedBadgesSubgraphUrl ?? '');\n\n    const idBadge = `${userId.toLowerCase()}#${badgeType}#${seasonId}`;\n    const badgeData = await client.query<{\n      badge: SubgraphBadgeResponse;\n    }>({\n      query: gql(badgeQuery),\n      variables: {\n        id: idBadge,\n      },\n    });\n    const badge: BadgeResponse = {\n      id: `${userId}#${seasonId}#${badgeType}`,\n      badgeType,\n      awardedTimestampMs: toMillis(seasonEnd),\n      mintedTimestampMs: toMillis(\n        parseInt(badgeData?.data?.badge ? badgeData.data.badge.mintedTimestamp : '0'),\n      ),\n    };\n    return badge;\n  }\n\n  public async getNonProgramaticBadges(\n    userId: string,\n    seasonId: number,\n    seasonStart: number,\n    seasonEnd: number,\n  ): Promise<Record<string, BadgeResponse>> {\n    const badgeResponseRecord: Record<string, BadgeResponse> = {};\n\n    const resp = await axios.get(`${this.nonProgDbUrl}/get-badges/${userId}`);\n    if (!resp.data) {\n      return badgeResponseRecord;\n    }\n\n    const badges: NonProgramaticBadgeResponse[] = resp.data.badges;\n    badges.forEach((entry) => {\n      const badgeType = NON_PROGRAMATIC_BADGES_VARIANT[seasonId][entry.badge];\n      if (\n        badgeType &&\n        entry.awardedTimestamp <= seasonEnd &&\n        entry.awardedTimestamp >= seasonStart\n      ) {\n        badgeResponseRecord[badgeType] = {\n          id: `${userId}#${badgeType}#${seasonId}`,\n          badgeType,\n          awardedTimestampMs: toMillis(entry.awardedTimestamp),\n          mintedTimestampMs: undefined,\n        } as BadgeResponse;\n      }\n    });\n    return badgeResponseRecord;\n  }\n\n  public async getReferrorBadges(\n    userId: string,\n    seasonId: number,\n    selectedBadgesSubgraphUrl: string,\n  ): Promise<Record<string, BadgeResponse>> {\n    const badgeResponseRecord: Record<string, BadgeResponse> = {};\n\n    const resp = await axios.get(`${this.referralsDbUrl}/referrals-by/${userId.toLowerCase()}`);\n    if (!resp.data) {\n      return badgeResponseRecord;\n    }\n    const referees: string[] = resp.data;\n    const lowerCaseReferees = referees.reduce(\n      (pV, cV) => [...pV, cV.toLowerCase()],\n      [] as Array<string>,\n    );\n\n    const refereesQuery = `\n            query( $ids: [String], $season: BigInt) {\n                seasonUsers( where: {owner_in: $ids, seasonNumber: $season}) {\n                    id\n                    owner {\n                        id\n                    }\n                    totalWeightedNotionalTraded\n                }\n            }\n        `;\n\n    const client = getApolloClient(selectedBadgesSubgraphUrl ?? '');\n    const data = await client.query<{\n      seasonUsers: {\n        totalWeightedNotionalTraded: string;\n        owner: { id: string };\n      }[];\n    }>({\n      query: gql(refereesQuery),\n      variables: {\n        ids: lowerCaseReferees,\n        season: seasonId,\n      },\n    });\n\n    if (!data?.data?.seasonUsers) {\n      throw new Error('Unable to get referees from subgraph');\n    }\n\n    let refereesWith100kNotionalTraded = 0;\n    let refereesWith2mNotionalTraded = 0;\n    for (const seasonUser of data.data.seasonUsers) {\n      const totalPointz = parseFloat(seasonUser.totalWeightedNotionalTraded);\n      if (totalPointz >= get100KRefereeBenchmark(selectedBadgesSubgraphUrl)) {\n        refereesWith100kNotionalTraded++;\n        if (totalPointz >= get2MRefereeBenchmark(selectedBadgesSubgraphUrl)) {\n          refereesWith2mNotionalTraded++;\n        }\n      }\n    }\n\n    if (refereesWith100kNotionalTraded >= 1) {\n      let badgeType = REFERROR_BADGES_VARIANT[seasonId].referror;\n      badgeResponseRecord[badgeType] = this.createReferroorBadgeRecord(badgeType, userId, seasonId);\n      if (refereesWith100kNotionalTraded >= 10) {\n        badgeType = REFERROR_BADGES_VARIANT[seasonId].notionalInfluencer;\n        badgeResponseRecord[badgeType] = this.createReferroorBadgeRecord(\n          badgeType,\n          userId,\n          seasonId,\n        );\n      }\n    }\n    if (refereesWith2mNotionalTraded >= 5) {\n      const badgeType = REFERROR_BADGES_VARIANT[seasonId].whaleWhisperer;\n      badgeResponseRecord[badgeType] = this.createReferroorBadgeRecord(badgeType, userId, seasonId);\n    }\n    return badgeResponseRecord;\n  }\n\n  createReferroorBadgeRecord(badgeType: string, userId: string, seasonId: number): BadgeResponse {\n    return {\n      id: `${userId}#${badgeType}#${seasonId}`,\n      badgeType,\n      awardedTimestampMs: toMillis(DateTime.now().toSeconds()),\n      mintedTimestampMs: undefined,\n    } as BadgeResponse;\n  }\n\n  public async getUserBalance(user: string): Promise<BigNumber | void> {\n    const balance = await this.contract?.balanceOf(user);\n    return balance;\n  }\n\n  public async getTokenOwner(tokenId: string): Promise<string | void> {\n    const owner = await this.contract?.ownerOf(tokenId);\n    return owner;\n  }\n\n  public async getTotalSupply(): Promise<BigNumber | void> {\n    const totalSupply = await this.contract?.totalSupply();\n    return totalSupply;\n  }\n\n  public async getBadgeStatus(args: GetBadgesStatusArgs): Promise<Array<BadgeWithStatus>> {\n    if (!this.signer) {\n      throw new Error('No provider found');\n    }\n    const userAddress = await this.signer.getAddress();\n    const network = await this.provider?.getNetwork();\n    const networkName = network ? network.name : '';\n\n    const getURL = getEtherscanURL(networkName, args.apiKey, userAddress);\n    const resp = await axios.get(getURL);\n\n    if (!resp.data) {\n      throw new Error('Etherscan api failed');\n    }\n    const transactions = resp.data.result;\n\n    // get last 50 transactions, match is redeem and set SUCC/FAILED status\n    const txBadges = new Map<number, TxBadgeStatus>();\n    for (const transaction of transactions) {\n      if (transaction.to.toLowerCase() !== this.contract?.address.toLowerCase()) {\n        continue;\n      }\n      const status =\n        transaction.txreceipt_status === 1 ? TxBadgeStatus.SUCCESSFUL : TxBadgeStatus.FAILED;\n      if (transaction.methodId === REDEEM_METHOD_ID) {\n        const badgeType = decodeBadgeType(transaction.input);\n        txBadges.set(badgeType, status);\n      } else if (transaction.methodId === MULTI_REDEEM_METHOD_ID) {\n        const badgeTypes = decodeMultipleBadgeTypes(transaction.input);\n        for (const badgeType of badgeTypes) {\n          txBadges.set(badgeType, status);\n        }\n      }\n    }\n\n    // if badges of interest are not part of those 50 transactions, set them as pending\n    for (const badgeType of args.potentialClaimingBadgeTypes) {\n      if (!txBadges.get(badgeType)) {\n        txBadges.set(badgeType, TxBadgeStatus.PENDING);\n      }\n    }\n\n    // badges claiming status in subgraph - includes all bades earned by user in given season\n    const selectedBadgesSubgraphUrl = getSelectedSeasonBadgesUrl(\n      args.season,\n      this.badgesCids,\n      this.currentBadgesSubgraphUrl,\n      this.nextBadgesSubgraphUrl,\n    );\n    const subgraphClaimedBadges = await this.claimedBadgesInSubgraph(\n      userAddress,\n      args.season,\n      selectedBadgesSubgraphUrl,\n    );\n\n    // final claiming status verdict\n    const badgeStatuses = subgraphClaimedBadges.map((badge) => {\n      if (badge.claimingStatus === BadgeClaimingStatus.CLAIMED) {\n        return badge;\n      }\n      const txStatus = txBadges.get(badge.badgeType);\n\n      // badge not found in recent successful txs or in potential pending txs\n      // meaning their status is desided by the subgraph\n      if (!txStatus || txStatus === TxBadgeStatus.FAILED) {\n        return {\n          badgeType: badge.badgeType,\n          claimingStatus: badge.claimingStatus,\n        };\n      }\n      // subgraph is not updated yet\n      return {\n        badgeType: badge.badgeType,\n        claimingStatus: BadgeClaimingStatus.CLAIMING,\n      };\n    });\n\n    return badgeStatuses;\n  }\n\n  async claimedBadgesInSubgraph(\n    userAddress: string,\n    season: number,\n    selectedBadgesSubgraphUrl?: string,\n  ): Promise<Array<BadgeWithStatus>> {\n    const badgeQuery = `\n            query( $id: String) {\n                badges(first: 50, where: {seasonUser_contains: $id}) {\n                    id\n                    badgeType\n                    awardedTimestamp\n                    mintedTimestamp\n                }\n            }\n        `;\n    const client = getApolloClient(selectedBadgesSubgraphUrl ?? '');\n    const id = `${userAddress.toLowerCase()}#${season}`;\n    const data = await client.query<{\n      badges: SubgraphBadgeResponse[];\n    }>({\n      query: gql(badgeQuery),\n      variables: {\n        id,\n      },\n    });\n\n    const badgesClaimed = new Array<BadgeWithStatus>();\n    for (const badge of data.data.badges) {\n      badgesClaimed.push({\n        badgeType: parseInt(badge.badgeType, 10),\n        claimingStatus:\n          parseInt(badge.mintedTimestamp, 10) === 0\n            ? BadgeClaimingStatus.NOT_CLAIMED\n            : BadgeClaimingStatus.CLAIMED, // only from subgraph's perspective\n      });\n    }\n\n    return badgesClaimed;\n  }\n}\n\nexport default SBT;\n"]}