{"version":3,"file":"priceTickConversions.js","sourceRoot":"/","sources":["utils/priceTickConversions.ts"],"names":[],"mappings":";;;;;;AAAA,mDAAmD;AACnD,8CAAwB;AACxB,qDAAoD;AACpD,0CAAwD;AACxD,2DAA0D;AAC1D,uCAAsC;AAEtC;;;;;;GAMG;AACH,SAAgB,WAAW,CAAC,IAAY;IACtC,IAAM,YAAY,GAAG,mBAAQ,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;IAEvD,IAAM,SAAS,GAAG,cAAI,CAAC,QAAQ,CAAC,YAAY,EAAE,YAAY,CAAC,CAAC;IAE5D,OAAO,IAAI,aAAK,CAAC,gBAAI,EAAE,SAAS,CAAC,CAAC;AACpC,CAAC;AAND,kCAMC;AAED,SAAgB,gBAAgB,CAAC,KAAY;IAC3C,OAAO,IAAI,aAAK,CAAC,KAAK,CAAC,SAAS,EAAE,KAAK,CAAC,WAAW,CAAC,CAAC;AACvD,CAAC;AAFD,4CAEC;AAED;;;;;;GAMG;AACH,SAAgB,eAAe,CAAC,IAAY;IAC1C,IAAI,WAAW,GAAG,IAAI,CAAC;IACvB,IAAI,IAAI,GAAG,oBAAQ,EAAE;QACnB,WAAW,GAAG,oBAAQ,CAAC;KACxB;IACD,IAAI,IAAI,GAAG,oBAAQ,EAAE;QACnB,WAAW,GAAG,oBAAQ,CAAC;KACxB;IAED,IAAM,KAAK,GAAU,WAAW,CAAC,WAAW,CAAC,CAAC;IAE9C,OAAO,gBAAgB,CAAC,KAAK,CAAC,CAAC;AACjC,CAAC;AAZD,0CAYC;AAED;;;;GAIG;AACH,SAAgB,kBAAkB,CAAC,KAAY;IAC7C,IAAM,YAAY,GAAG,IAAA,uCAAkB,EAAC,KAAK,CAAC,SAAS,EAAE,KAAK,CAAC,WAAW,CAAC,CAAC;IAE5E,IAAI,IAAI,GAAG,mBAAQ,CAAC,kBAAkB,CAAC,YAAY,CAAC,CAAC;IAErD,IAAM,aAAa,GAAG,WAAW,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;IAE5C,iDAAiD;IACjD,IAAI,IAAI,GAAG,CAAC,EAAE;QACZ,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,aAAa,CAAC,EAAE;YAClC,IAAI,IAAI,CAAC,CAAC;SACX;KACF;IAED,OAAO,IAAI,CAAC;AACd,CAAC;AAfD,gDAeC;AAED,SAAgB,gBAAgB,CAAC,SAAgB;IAC/C,gDAAgD;IAChD,sHAAsH;IACtH,OAAO,IAAI,aAAK,CAAC,SAAS,CAAC,SAAS,EAAE,SAAS,CAAC,WAAW,CAAC,CAAC;AAC/D,CAAC;AAJD,4CAIC;AAED,SAAgB,sBAAsB,CAAC,SAAgB;IACrD,sBAAsB;IACtB,IAAM,KAAK,GAAG,gBAAgB,CAAC,SAAS,CAAC,CAAC;IAC1C,wBAAwB;IACxB,OAAO,kBAAkB,CAAC,KAAK,CAAC,CAAC;AACnC,CAAC;AALD,wDAKC","sourcesContent":["// import { Price, Token } from '@uniswap/sdk-core'\nimport JSBI from 'jsbi';\nimport { Price } from '../entities/fractions/price';\nimport { MAX_TICK, MIN_TICK, Q192 } from '../constants';\nimport { encodeSqrtRatioX96 } from './encodeSqrtRatioX96';\nimport { TickMath } from './tickMath';\n\n/**\n * Returns a price object corresponding to the input tick\n * Inputs must be tokens because the address order is used to interpret the price represented by the tick\n * @param baseToken the base token of the price\n * @param quoteToken the quote token of the price\n * @param tick the tick for which to return the price\n */\nexport function tickToPrice(tick: number) {\n  const sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\n\n  const ratioX192 = JSBI.multiply(sqrtRatioX96, sqrtRatioX96);\n\n  return new Price(Q192, ratioX192);\n}\n\nexport function priceToFixedRate(price: Price) {\n  return new Price(price.numerator, price.denominator);\n}\n\n/**\n * Returns a price object corresponding to the input tick, the price object represents the fixed rate in percentage point (e.g. 1.2 corresponds to 1.2% --> 0.012)\n * Inputs must be tokens because the address order is used to interpret the price represented by the tick\n * @param baseToken the base token of the price\n * @param quoteToken the quote token of the price\n * @param tick the tick for which to return the price\n */\nexport function tickToFixedRate(tick: number) {\n  let inRangeTick = tick;\n  if (tick < MIN_TICK) {\n    inRangeTick = MIN_TICK;\n  }\n  if (tick > MAX_TICK) {\n    inRangeTick = MAX_TICK;\n  }\n\n  const price: Price = tickToPrice(inRangeTick);\n\n  return priceToFixedRate(price);\n}\n\n/**\n * Returns the first tick for which the given price is greater than or equal to the tick price\n * @param price for which to return the closest tick that represents a price less than or equal to the input price,\n * i.e. the price of the returned tick is less than or equal to the input price\n */\nexport function priceToClosestTick(price: Price): number {\n  const sqrtRatioX96 = encodeSqrtRatioX96(price.numerator, price.denominator);\n\n  let tick = TickMath.getTickAtSqrtRatio(sqrtRatioX96);\n\n  const nextTickPrice = tickToPrice(tick + 1);\n\n  // this solution is a bit hacky, can be optimised\n  if (tick < 0) {\n    if (!price.lessThan(nextTickPrice)) {\n      tick += 1;\n    }\n  }\n\n  return tick;\n}\n\nexport function fixedRateToPrice(fixedRate: Price) {\n  // the fixed rate is the reciprocal of the price\n  // NOTE: below the first argument to the Price constructor is the denominator and the second argument is the numerator\n  return new Price(fixedRate.numerator, fixedRate.denominator);\n}\n\nexport function fixedRateToClosestTick(fixedRate: Price) {\n  // fixed rate to price\n  const price = fixedRateToPrice(fixedRate);\n  // price to closest tick\n  return priceToClosestTick(price);\n}\n"]}