{"version":3,"file":"sqrt.js","sourceRoot":"/","sources":["utils/sqrt.ts"],"names":[],"mappings":";;;;;;AAAA,8CAAwB;AACxB,kEAAuC;AAE1B,QAAA,gBAAgB,GAAG,cAAI,CAAC,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC;AAErE,IAAM,IAAI,GAAG,cAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AAC5B,IAAM,GAAG,GAAG,cAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AAC3B,IAAM,GAAG,GAAG,cAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AAE3B;;;GAGG;AACH,SAAgB,IAAI,CAAC,KAAW;IAC9B,IAAA,wBAAS,EAAC,cAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,IAAI,CAAC,EAAE,UAAU,CAAC,CAAC;IAE5D,oCAAoC;IACpC,IAAI,cAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,wBAAgB,CAAC,EAAE;QAC1C,OAAO,cAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,cAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;KACjE;IAED,IAAI,CAAO,CAAC;IACZ,IAAI,CAAO,CAAC;IACZ,CAAC,GAAG,KAAK,CAAC;IACV,CAAC,GAAG,cAAI,CAAC,GAAG,CAAC,cAAI,CAAC,MAAM,CAAC,KAAK,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC;IAC3C,OAAO,cAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE;QAC1B,CAAC,GAAG,CAAC,CAAC;QACN,CAAC,GAAG,cAAI,CAAC,MAAM,CAAC,cAAI,CAAC,GAAG,CAAC,cAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;KAC1D;IACD,OAAO,CAAC,CAAC;AACX,CAAC;AAjBD,oBAiBC","sourcesContent":["import JSBI from 'jsbi';\nimport invariant from 'tiny-invariant';\n\nexport const MAX_SAFE_INTEGER = JSBI.BigInt(Number.MAX_SAFE_INTEGER);\n\nconst ZERO = JSBI.BigInt(0);\nconst ONE = JSBI.BigInt(1);\nconst TWO = JSBI.BigInt(2);\n\n/**\n * Computes floor(sqrt(value))\n * @param value the value for which to compute the square root, rounded down\n */\nexport function sqrt(value: JSBI): JSBI {\n  invariant(JSBI.greaterThanOrEqual(value, ZERO), 'NEGATIVE');\n\n  // rely on built in sqrt if possible\n  if (JSBI.lessThan(value, MAX_SAFE_INTEGER)) {\n    return JSBI.BigInt(Math.floor(Math.sqrt(JSBI.toNumber(value))));\n  }\n\n  let z: JSBI;\n  let x: JSBI;\n  z = value;\n  x = JSBI.add(JSBI.divide(value, TWO), ONE);\n  while (JSBI.lessThan(x, z)) {\n    z = x;\n    x = JSBI.divide(JSBI.add(JSBI.divide(value, x), x), TWO);\n  }\n  return z;\n}\n"]}