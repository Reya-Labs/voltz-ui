{"version":3,"file":"merkle-tree.js","sourceRoot":"/","sources":["utils/communitySbt/merkle-tree.ts"],"names":[],"mappings":";;;;;;AAAA,6CAA0C;AAC1C,wDAAkC;AAClC,iCAA2C;AAG3C,IAAM,OAAO,GAAG,UAAC,OAAe,EAAE,SAAiB;IACjD,OAAO,MAAM,CAAC,IAAI,CAChB,eAAM,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAC,SAAS,EAAE,QAAQ,CAAC,EAAE,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EACpF,KAAK,CACN,CAAC;AACJ,CAAC,CAAC;AAEF,IAAM,aAAa,GAAG,UAAC,MAAuB;IAC5C,IAAM,SAAS,GAAG,MAAM,CAAC,GAAG,CAAC,UAAC,KAAK;QACjC,OAAO,OAAO,CAAC,KAAK,CAAC,OAAO,EAAE,KAAK,CAAC,OAAO,CAAC,CAAC;IAC/C,CAAC,CAAC,CAAC;IAEH,IAAM,UAAU,GAAG,IAAI,yBAAU,CAAC,SAAS,EAAE,mBAAS,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;IAE7E,OAAO,UAAU,CAAC;AACpB,CAAC,CAAC;AAEK,IAAM,QAAQ,GAAG,UAAC,OAAe,EAAE,SAAiB,EAAE,MAAuB;IAClF,IAAM,UAAU,GAAG,aAAa,CAAC,MAAM,CAAC,CAAC;IAEzC,IAAM,KAAK,GAAG,UAAU,CAAC,WAAW,CAAC,OAAO,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC,CAAC;IAElE,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;QACtB,MAAM,IAAI,KAAK,CACb,iEAA0D,OAAO,0BAAgB,SAAS,MAAG,CAC9F,CAAC;KACH;IAED,OAAO,KAAK,CAAC;AACf,CAAC,CAAC;AAZW,QAAA,QAAQ,YAYnB;AAEK,IAAM,UAAU,GAAG,UAAC,OAAe,EAAE,UAAkB,EAAE,SAAiB;IAC/E,OAAO,kBAAS,CAAC,IAAI,CACnB,eAAM,CAAC,KAAK,CAAC,iBAAiB,CAC5B,CAAC,SAAS,EAAE,SAAS,EAAE,QAAQ,CAAC,EAChC,CAAC,OAAO,EAAE,UAAU,EAAE,SAAS,CAAC,CACjC,CACF,CAAC;AACJ,CAAC,CAAC;AAPW,QAAA,UAAU,cAOrB","sourcesContent":["import { MerkleTree } from 'merkletreejs';\nimport keccak256 from 'keccak256';\nimport { BigNumber, ethers } from 'ethers';\nimport { LeafInfo } from '../../entities/communitySbt';\n\nconst getLeaf = (address: string, badgeType: number): Buffer => {\n  return Buffer.from(\n    ethers.utils.solidityKeccak256(['address', 'uint96'], [address, badgeType]).slice(2),\n    'hex',\n  );\n};\n\nconst getMerkleTree = (leaves: Array<LeafInfo>): MerkleTree => {\n  const leafNodes = leaves.map((entry) => {\n    return getLeaf(entry.account, entry.badgeId);\n  });\n\n  const merkleTree = new MerkleTree(leafNodes, keccak256, { sortPairs: true });\n\n  return merkleTree;\n};\n\nexport const getProof = (address: string, badgeType: number, leaves: Array<LeafInfo>): string[] => {\n  const merkleTree = getMerkleTree(leaves);\n\n  const proof = merkleTree.getHexProof(getLeaf(address, badgeType));\n\n  if (proof.length === 0) {\n    throw new Error(\n      `Cannot prove something that is not in tree: { address: ${address}, badgeType: ${badgeType}}`,\n    );\n  }\n\n  return proof;\n};\n\nexport const getTokenId = (account: string, merkleRoot: string, badgeType: number): BigNumber => {\n  return BigNumber.from(\n    ethers.utils.solidityKeccak256(\n      ['address', 'bytes32', 'uint96'],\n      [account, merkleRoot, badgeType],\n    ),\n  );\n};\n"]}