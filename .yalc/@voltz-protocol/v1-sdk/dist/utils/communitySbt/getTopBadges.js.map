{"version":3,"file":"getTopBadges.js","sourceRoot":"/","sources":["utils/communitySbt/getTopBadges.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,yCAAqC;AACrC,iCAAgC;AAChC,6CAAsD;AACtD,qDAAoD;AA0BpD,IAAY,UAIX;AAJD,WAAY,UAAU;IACpB,2CAAI,CAAA;IACJ,2CAAI,CAAA;IACJ,2CAAI,CAAA;AACN,CAAC,EAJW,UAAU,GAAV,kBAAU,KAAV,kBAAU,QAIrB;AAcD,SAAS,WAAW,CAAC,EAUH;QAThB,KAAK,WAAA,EACL,OAAO,aAAA,EACP,UAAU,gBAAA,EACV,QAAQ,cAAA,EACR,KAAK,WAAA,EACL,WAAW,iBAAA,EACX,SAAS,eAAA,EACT,OAAO,aAAA,EACP,QAAQ,cAAA;IAER,IAAI,eAAe,GAAG,KAAK,CAAC;IAC5B,KAAqB,UAAO,EAAP,mBAAO,EAAP,qBAAO,EAAP,IAAO,EAAE;QAAzB,IAAM,MAAM,gBAAA;QACf,IAAM,UAAU,GAAW,MAAM,CAAC,WAAW,CAAC,gBAAgB,CAAC;QAC/D,IAAI,MAAM,GAAG,EAAE,CAAC;QAChB,QAAQ,UAAU,EAAE;YAClB,KAAK,UAAU,CAAC,IAAI;gBAClB,MAAM,GAAI,MAAqB,CAAC,kBAAkB,CAAC,QAAQ,EAAE,CAAC;gBAC9D,MAAM;YACR,KAAK,UAAU,CAAC,IAAI,CAAC;YACrB,KAAK,UAAU,CAAC,IAAI;gBAClB,MAAM,GAAI,MAA2B,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC;gBACxD,MAAM;YACR;gBACE,MAAM,GAAG,GAAG,CAAC;gBACb,MAAM;SACT;QACD,IAAM,YAAY,GAAG,MAAM,CAAC,eAAM,CAAC,KAAK,CAAC,WAAW,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC,CAAC;QAExE,IAAI,WAAW,GAAG,UAAU,IAAI,UAAU,IAAI,SAAS,EAAE;YACvD,IAAM,oBAAoB,GACxB,CAAC,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,GAAG,CAAC,OAAO,GAAG,UAAU,CAAC,CAAC,GAAG,+BAAmB,CAAC;YAC1E,QAAQ,KAAK,EAAE;gBACb,KAAK,KAAK,CAAC,CAAC;oBACV,eAAe;wBACb,CAAC,UAAU,KAAK,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,oBAAoB,GAAG,QAAQ,CAAC;oBAC9E,MAAM;iBACP;gBACD,OAAO,CAAC,CAAC;oBACP,eAAe,IAAI,CAAC,UAAU,KAAK,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,oBAAoB,CAAC;iBACrF;aACF;SACF;KACF;IACD,OAAO,eAAe,CAAC;AACzB,CAAC;AAED;;;;GAIG;AACH,SAAsB,SAAS,CAAC,EAOhB;;QANd,WAAW,iBAAA,EACX,SAAS,eAAA,EACT,WAAW,iBAAA,EACX,QAAQ,cAAA,EACR,gBAAgB,sBAAA,EAChB,IAAI,UAAA;;;;;;oBAEE,aAAa,GAAG,goCAoCjB,CAAC;oBAEA,MAAM,GAAG,IAAA,iCAAe,EAAC,WAAW,CAAC,CAAC;oBAEtC,MAAM,GAA2B,EAAE,CAAC;oBAEtC,MAAM,GAAG,GAAG,CAAC;;;yBACV,IAAI;oBACI,qBAAM,MAAM,CAAC,KAAK,CAAC;4BAC9B,KAAK,EAAE,IAAA,YAAG,EAAC,aAAa,CAAC;4BACzB,SAAS,EAAE;gCACT,MAAM,QAAA;6BACP;yBACF,CAAC,EAAA;;oBALI,IAAI,GAAG,SAKX;oBAEI,OAAO,GAAG,MAAA,MAAA,IAAI,aAAJ,IAAI,uBAAJ,IAAI,CAAE,IAAI,0CAAE,OAAO,mCAAI,EAAE,CAAC;oBAE1C,WAA4B,EAAP,mBAAO,EAAP,qBAAO,EAAP,IAAO,EAAE;wBAAnB,MAAM;wBACX,KAAK,GAAG,CAAC,CAAC;wBAEd,WAAuC,EAAhB,KAAA,MAAM,CAAC,SAAS,EAAhB,cAAgB,EAAhB,IAAgB,EAAE;4BAA9B,QAAQ;4BACX,KAAK,GAAG,QAAQ,CAAC,GAAG,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC;4BAC3C,QAAQ,GAAW,QAAQ,CAAC,GAAG,CAAC,UAAU,CAAC,KAAK,CAAC,QAAQ,CAAC;4BAE1D,OAAO,GAAG,MAAM,CACpB,eAAM,CAAC,KAAK,CAAC,WAAW,CAAC,QAAQ,CAAC,GAAG,CAAC,gBAAgB,CAAC,QAAQ,EAAE,EAAE,EAAE,CAAC,CACvE,CAAC;4BAEI,IAAI,GAAoB;gCAC5B,KAAK,OAAA;gCACL,OAAO,EAAE,QAAQ,CAAC,KAA2B;gCAC7C,UAAU,EAAE,UAAU,CAAC,IAAI;gCAC3B,QAAQ,UAAA;gCACR,KAAK,OAAA;gCACL,WAAW,aAAA;gCACX,SAAS,WAAA;gCACT,OAAO,SAAA;gCACP,QAAQ,UAAA;6BACT,CAAC;4BACF,IAAI,IAAI,EAAE;gCACF,QAAQ,yBACT,IAAI,KACP,UAAU,EAAE,UAAU,CAAC,IAAI,EAC3B,OAAO,EAAE,QAAQ,CAAC,KAA2B,GAC9C,CAAC;gCACF,KAAK,GAAG,WAAW,CAAC,QAAQ,CAAC,CAAC;gCACxB,QAAQ,yBACT,IAAI,KACP,KAAK,OAAA,EACL,UAAU,EAAE,UAAU,CAAC,IAAI,EAC3B,OAAO,EAAE,QAAQ,CAAC,KAA2B,GAC9C,CAAC;gCACF,KAAK,GAAG,WAAW,CAAC,QAAQ,CAAC,CAAC;6BAC/B;iCAAM;gCACC,QAAQ,yBACT,IAAI,KACP,UAAU,EAAE,UAAU,CAAC,IAAI,EAC3B,OAAO,EAAE,QAAQ,CAAC,KAAqB,GACxC,CAAC;gCACF,KAAK,GAAG,WAAW,CAAC,QAAQ,CAAC,CAAC;6BAC/B;yBACF;wBAED,IAAI,KAAK,GAAG,CAAC,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,EAAE,CAAC,WAAW,EAAE,CAAC,EAAE;4BAC3D,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC;yBAC3B;wBACD,MAAM,GAAG,MAAM,CAAC,EAAE,CAAC;qBACpB;oBAED,IAAI,OAAO,GAAG,IAAI,EAAE;wBAClB,wBAAM;qBACP;;wBAEH,sBAAO,MAAM,EAAC;;;;CACf;AAtHD,8BAsHC","sourcesContent":["import { gql } from '@apollo/client';\nimport { ethers } from 'ethers';\nimport { ONE_YEAR_IN_SECONDS } from '../../constants';\nimport { getApolloClient } from './getApolloClient';\n\nexport type GetScoresArgs = {\n  seasonStart: number;\n  seasonEnd: number;\n  subgraphUrl: string;\n  ethPrice: number;\n  ignoredWalletIds: Record<string, boolean>;\n  isLP: boolean;\n};\n\nexport type MintOrBurnAction = {\n  transaction: {\n    createdTimestamp: number;\n  };\n  amount: string;\n};\n\nexport type SwapAction = {\n  transaction: {\n    createdTimestamp: number;\n  };\n  cumulativeFeeIncurred: number;\n  variableTokenDelta: string;\n};\n\nexport enum ActionType {\n  SWAP,\n  MINT,\n  BURN,\n}\n\nexport type UpdateScoreArgs = {\n  score: number;\n  actions: MintOrBurnAction[] | SwapAction[];\n  actionType: ActionType;\n  decimals: number;\n  token: string;\n  seasonStart: number;\n  seasonEnd: number;\n  termEnd: number;\n  ethPrice: number;\n};\n\nfunction updateScore({\n  score,\n  actions,\n  actionType,\n  decimals,\n  token,\n  seasonStart,\n  seasonEnd,\n  termEnd,\n  ethPrice,\n}: UpdateScoreArgs): number {\n  let calculatedScore = score;\n  for (const action of actions) {\n    const actionTime: number = action.transaction.createdTimestamp;\n    let amount = '';\n    switch (actionType) {\n      case ActionType.SWAP:\n        amount = (action as SwapAction).variableTokenDelta.toString();\n        break;\n      case ActionType.MINT:\n      case ActionType.BURN:\n        amount = (action as MintOrBurnAction).amount.toString();\n        break;\n      default:\n        amount = '0';\n        break;\n    }\n    const mintNotional = Number(ethers.utils.formatUnits(amount, decimals));\n\n    if (seasonStart < actionTime && actionTime <= seasonEnd) {\n      const timeWeightedNotional =\n        (Math.abs(mintNotional) * (termEnd - actionTime)) / ONE_YEAR_IN_SECONDS;\n      switch (token) {\n        case 'ETH': {\n          calculatedScore +=\n            (actionType === ActionType.BURN ? -1 : 1) * timeWeightedNotional * ethPrice;\n          break;\n        }\n        default: {\n          calculatedScore += (actionType === ActionType.BURN ? -1 : 1) * timeWeightedNotional;\n        }\n      }\n    }\n  }\n  return calculatedScore;\n}\n\n/**\n * @dev Query the Main subgraph and retrieve season's liquidity\n * or trading score of all users based on time weighted liquidity.\n * Score is based on both mints and swaps.\n */\nexport async function getScores({\n  seasonStart,\n  seasonEnd,\n  subgraphUrl,\n  ethPrice,\n  ignoredWalletIds,\n  isLP,\n}: GetScoresArgs): Promise<Record<string, number>> {\n  const activityQuery = `\n        query( $lastId: String) {\n            wallets(first: 1000, where: {id_gt: $lastId}) {\n                id\n                positions {\n                    amm {\n                        termEndTimestamp\n                        rateOracle {\n                            token {\n                                name\n                                decimals\n                            }\n                        }\n                    }\n                    mints {\n                        transaction {\n                            createdTimestamp\n                        }\n                        amount\n                    }\n                    burns {\n                        transaction {\n                            createdTimestamp\n                        }\n                        amount\n                    }\n                    swaps {\n                        transaction {\n                            createdTimestamp\n                        }\n                        cumulativeFeeIncurred\n                        variableTokenDelta\n                    }\n                }\n            }\n        }\n      `;\n\n  const client = getApolloClient(subgraphUrl);\n\n  const scores: Record<string, number> = {};\n\n  let lastId = '0';\n  while (true) {\n    const data = await client.query({\n      query: gql(activityQuery),\n      variables: {\n        lastId,\n      },\n    });\n\n    const wallets = data?.data?.wallets ?? [];\n\n    for (const wallet of wallets) {\n      let score = 0;\n\n      for (const position of wallet.positions) {\n        const token = position.amm.rateOracle.token.name;\n        const decimals: number = position.amm.rateOracle.token.decimals;\n\n        const termEnd = Number(\n          ethers.utils.formatUnits(position.amm.termEndTimestamp.toString(), 18),\n        );\n\n        const args: UpdateScoreArgs = {\n          score,\n          actions: position.burns as MintOrBurnAction[],\n          actionType: ActionType.BURN,\n          decimals,\n          token,\n          seasonStart,\n          seasonEnd,\n          termEnd,\n          ethPrice,\n        };\n        if (isLP) {\n          const burnArgs: UpdateScoreArgs = {\n            ...args,\n            actionType: ActionType.BURN,\n            actions: position.burns as MintOrBurnAction[],\n          };\n          score = updateScore(burnArgs);\n          const mintArgs: UpdateScoreArgs = {\n            ...args,\n            score,\n            actionType: ActionType.MINT,\n            actions: position.mints as MintOrBurnAction[],\n          };\n          score = updateScore(mintArgs);\n        } else {\n          const swapArgs: UpdateScoreArgs = {\n            ...args,\n            actionType: ActionType.SWAP,\n            actions: position.swaps as SwapAction[],\n          };\n          score = updateScore(swapArgs);\n        }\n      }\n\n      if (score > 0 && !ignoredWalletIds[wallet.id.toLowerCase()]) {\n        scores[wallet.id] = score;\n      }\n      lastId = wallet.id;\n    }\n\n    if (wallets < 1000) {\n      break;\n    }\n  }\n  return scores;\n}\n"]}